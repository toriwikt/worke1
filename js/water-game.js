const gameLevels = {
    1: {
        title: "–†—ñ–≤–µ–Ω—å 1: –õ—ñ—Å–æ–≤–∏–π —Å—Ç—Ä—É–º–æ–∫",
        description: "–í–æ–¥–∞ –∑ –ø—Ä–∏—Ä–æ–¥–Ω–æ–≥–æ –¥–∂–µ—Ä–µ–ª–∞ –ø–æ—Ç—Ä–µ–±—É—î –±–∞–∑–æ–≤–æ–≥–æ –æ—á–∏—â–µ–Ω–Ω—è",
        requiredFilters: ["carbon"],
        waterQualityGoal: 100,
        hint: "üí° –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –≤—É–≥—ñ–ª—å–Ω–∏–π —Ñ—ñ–ª—å—Ç—Ä –¥–ª—è –±–∞–∑–æ–≤–æ–≥–æ –æ—á–∏—â–µ–Ω–Ω—è",
        tasks: [
            "–í–∏–¥–∞–ª–µ–Ω–Ω—è —Ö–ª–æ—Ä—É —Ç–∞ –æ—Ä–≥–∞–Ω—ñ—á–Ω–∏—Ö —Å–ø–æ–ª—É–∫",
            "–ü–æ–∫—Ä–∞—â–µ–Ω–Ω—è —Å–º–∞–∫—É —Ç–∞ –∑–∞–ø–∞—Ö—É –≤–æ–¥–∏"
        ],
        unlocked: true
    },
    2: {
        title: "–†—ñ–≤–µ–Ω—å 2: –í–æ–¥–∞ –∑ –∫–æ–ª–æ–¥—è–∑—è",
        description: "–í–æ–¥–∞ –∑ –∫–æ–ª–æ–¥—è–∑—è –º—ñ—Å—Ç–∏—Ç—å –Ω–∞–¥–ª–∏—à–æ–∫ –º—ñ–Ω–µ—Ä–∞–ª—ñ–≤",
        requiredFilters: ["carbon", "mineral"],
        waterQualityGoal: 100,
        hint: "üí° –í—É–≥—ñ–ª—å–Ω–∏–π —Ñ—ñ–ª—å—Ç—Ä ‚Üí –ú—ñ–Ω–µ—Ä–∞–ª—ñ–∑–∞—Ü—ñ—è",
        tasks: [
            "1. –û—á–∏—â–µ–Ω–Ω—è –≤—ñ–¥ –¥–æ–º—ñ—à–æ–∫",
            "2. –ó–±–∞–ª–∞–Ω—Å—É–≤–∞–Ω–Ω—è –º—ñ–Ω–µ—Ä–∞–ª—å–Ω–æ–≥–æ —Å–∫–ª–∞–¥—É"
        ],
        unlocked: true
    },
    3: {
        title: "–†—ñ–≤–µ–Ω—å 3: –í–æ–¥–∞ –∑ –º—ñ—Å—å–∫–æ–≥–æ –æ–∑–µ—Ä–∞",
        description: "–ó–∞–±—Ä—É–¥–Ω–µ–Ω–∞ –≤–æ–¥–∞ –∑ –º—ñ—Å—å–∫–æ–≥–æ –æ–∑–µ—Ä–∞",
        requiredFilters: ["carbon", "mineral", "membrane"],
        waterQualityGoal: 100,
        hint: "üí° –í—É–≥—ñ–ª—å–Ω–∏–π —Ñ—ñ–ª—å—Ç—Ä ‚Üí –ú—ñ–Ω–µ—Ä–∞–ª—ñ–∑–∞—Ü—ñ—è ‚Üí –ú–µ–º–±—Ä–∞–Ω–Ω–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è",
        tasks: [
            "1. –í–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞–±—Ä—É–¥–Ω–µ–Ω—å",
            "2. –ó–±–∞–ª–∞–Ω—Å—É–≤–∞–Ω–Ω—è –º—ñ–Ω–µ—Ä–∞–ª—å–Ω–æ–≥–æ —Å–∫–ª–∞–¥—É",
            "3. –¢–æ–Ω–∫–µ –æ—á–∏—â–µ–Ω–Ω—è —á–µ—Ä–µ–∑ –º–µ–º–±—Ä–∞–Ω—É"
        ],
        unlocked: true
    },
    4: {
        title: "–†—ñ–≤–µ–Ω—å 4: –†—ñ—á–∫–æ–≤–∞ –≤–æ–¥–∞",
        description: "–ó–∞–±—Ä—É–¥–Ω–µ–Ω–∞ —Ä—ñ—á–∫–æ–≤–∞ –≤–æ–¥–∞ –ø–æ—Ç—Ä–µ–±—É—î –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–≥–æ –æ—á–∏—â–µ–Ω–Ω—è",
        requiredFilters: ["carbon", "mineral", "membrane", "uv"],
        waterQualityGoal: 100,
        hint: "üí° –í—É–≥—ñ–ª—å–Ω–∏–π —Ñ—ñ–ª—å—Ç—Ä ‚Üí –ú—ñ–Ω–µ—Ä–∞–ª—ñ–∑–∞—Ü—ñ—è ‚Üí –ú–µ–º–±—Ä–∞–Ω–∞ ‚Üí –£–§-–æ—á–∏—â–µ–Ω–Ω—è",
        tasks: [
            "1. –í–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞–±—Ä—É–¥–Ω–µ–Ω—å",
            "2. –ó–±–∞–ª–∞–Ω—Å—É–≤–∞–Ω–Ω—è –º—ñ–Ω–µ—Ä–∞–ª—ñ–≤",
            "3. –ú–µ–º–±—Ä–∞–Ω–Ω–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è",
            "4. –£–§-–¥–µ–∑—ñ–Ω—Ñ–µ–∫—Ü—ñ—è"
        ],
        unlocked: true
    },
    5: {
        title: "–†—ñ–≤–µ–Ω—å 5: –ü—Ä–æ–º–∏—Å–ª–æ–≤—ñ –≤—ñ–¥—Ö–æ–¥–∏",
        description: "–í–æ–¥–∞ –∑–∞–±—Ä—É–¥–Ω–µ–Ω–∞ –ø—Ä–æ–º–∏—Å–ª–æ–≤–∏–º–∏ –≤—ñ–¥—Ö–æ–¥–∞–º–∏",
        requiredFilters: ["separation", "carbon", "membrane", "chemical"],
        waterQualityGoal: 100,
        hint: "üí° –°–µ–ø–∞—Ä–∞—Ü—ñ—è ‚Üí –í—É–≥—ñ–ª—å–Ω–∏–π —Ñ—ñ–ª—å—Ç—Ä ‚Üí –ú–µ–º–±—Ä–∞–Ω–∞ ‚Üí –•—ñ–º—ñ—á–Ω–µ –æ—á–∏—â–µ–Ω–Ω—è",
        tasks: [
            "1. –ú–µ—Ö–∞–Ω—ñ—á–Ω–∞ —Å–µ–ø–∞—Ä–∞—Ü—ñ—è",
            "2. –í—É–≥—ñ–ª—å–Ω–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è",
            "3. –ú–µ–º–±—Ä–∞–Ω–Ω–µ –æ—á–∏—â–µ–Ω–Ω—è",
            "4. –•—ñ–º—ñ—á–Ω–∞ –æ–±—Ä–æ–±–∫–∞"
        ],
        unlocked: true
    },
    6: {
        title: "–†—ñ–≤–µ–Ω—å 6: –†–∞–¥—ñ–æ–∞–∫—Ç–∏–≤–Ω–µ –∑–∞–±—Ä—É–¥–Ω–µ–Ω–Ω—è",
        description: "–í–æ–¥–∞ –º—ñ—Å—Ç–∏—Ç—å —Ä–∞–¥—ñ–æ–∞–∫—Ç–∏–≤–Ω—ñ —á–∞—Å—Ç–∏–Ω–∫–∏",
        requiredFilters: ["precipitation", "ion", "membrane", "adsorption"],
        waterQualityGoal: 100,
        hint: "üí° –û—Å–∞–¥–∂–µ–Ω–Ω—è ‚Üí –Ü–æ–Ω–Ω–∏–π –æ–±–º—ñ–Ω ‚Üí –ú–µ–º–±—Ä–∞–Ω–∞ ‚Üí –ê–¥—Å–æ—Ä–±—Ü—ñ—è",
        tasks: [
            "1. –û—Å–∞–¥–∂–µ–Ω–Ω—è —Ä–∞–¥—ñ–æ–∞–∫—Ç–∏–≤–Ω–∏—Ö —á–∞—Å—Ç–∏–Ω–æ–∫",
            "2. –Ü–æ–Ω–Ω–∏–π –æ–±–º—ñ–Ω –¥–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è —Ä–∞–¥—ñ–æ–∞–∫—Ç–∏–≤–Ω–∏—Ö —ñ–æ–Ω—ñ–≤",
            "3. –ú–µ–º–±—Ä–∞–Ω–Ω–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è –∑–∞–ª–∏—à–∫–æ–≤–∏—Ö —á–∞—Å—Ç–∏–Ω–æ–∫",
            "4. –ê–¥—Å–æ—Ä–±—Ü—ñ—è –∑–∞–ª–∏—à–∫–æ–≤–∏—Ö —Ä–∞–¥—ñ–æ–∞–∫—Ç–∏–≤–Ω–∏—Ö —Ä–µ—á–æ–≤–∏–Ω"
        ],
        unlocked: true
    }
};

let currentLevel = 1;
let appliedFilters = [];
let completedLevels = new Set();

// DOM Elements
const waterGlass = document.getElementById('water-glass');
const availableFilters = document.getElementById('available-filters');
const statusMessage = document.querySelector('.status-message');
const levelButtons = document.querySelectorAll('.level-button');
const waterQualityMeter = document.querySelector('.meter-fill');
const qualityText = document.querySelector('.quality-text');
const levelTasks = document.getElementById('level-tasks');

// Initialize the game
function initGame(level) {
    currentLevel = level;
    appliedFilters = [];
    updateWaterQuality(0);
    updateLevelInfo(level);
    updateAvailableFilters(level);
    updateTasks(level);
    resetWaterGlass();
    updateLevelButtons();
}

// Update level information
function updateLevelInfo(level) {
    const levelInfo = gameLevels[level];
    document.getElementById('current-level-title').textContent = levelInfo.title;
    document.getElementById('level-description').textContent = levelInfo.description;
    
    // Add hint to level description
    const hintElement = document.createElement('p');
    hintElement.className = 'level-hint';
    hintElement.textContent = `üí° ${levelInfo.hint}`;
    document.getElementById('level-description').appendChild(hintElement);
}

// Update tasks list
function updateTasks(level) {
    const tasks = gameLevels[level].tasks;
    levelTasks.innerHTML = '';
    tasks.forEach(task => {
        const li = document.createElement('li');
        li.textContent = task;
        levelTasks.appendChild(li);
    });
}

// Update available filters based on level
function updateAvailableFilters(level) {
    const filters = document.querySelectorAll('.filter-item');
    
    filters.forEach(filter => {
        // Show only filters that match the current level class
        if (filter.classList.contains(`level-${level}`)) {
            filter.style.display = 'block';
        } else {
            filter.style.display = 'none';
        }
    });
}

// Update water quality meter
function updateWaterQuality(quality) {
    const displayQuality = quality === gameLevels[currentLevel].waterQualityGoal ? 100 : quality;
    waterQualityMeter.style.width = `${displayQuality}%`;
    qualityText.textContent = `–Ø–∫—ñ—Å—Ç—å –≤–æ–¥–∏: ${displayQuality}%`;
}

// Reset water glass
function resetWaterGlass() {
    // Remove applied filters container if it exists
    const appliedFiltersContainer = waterGlass.querySelector('.applied-filters');
    if (appliedFiltersContainer) {
        appliedFiltersContainer.innerHTML = '';
    }
    
    appliedFilters = [];
    updateWaterQuality(0);
    statusMessage.textContent = '';
    updateWaterColor(0);
    
    // Reset task completion
    const tasks = document.querySelectorAll('#level-tasks li');
    tasks.forEach(task => task.classList.remove('completed'));
}

// Update water color based on quality
function updateWaterColor(quality) {
    const water = document.querySelector('.water');
    if (quality === 0) {
        water.style.backgroundColor = '#8B4513';
    } else if (quality < 50) {
        water.style.backgroundColor = '#C2B280';
    } else if (quality < 80) {
        water.style.backgroundColor = '#87CEEB';
    } else {
        water.style.backgroundColor = '#00BFFF';
    }
}

// Calculate water quality based on applied filters
function calculateWaterQuality() {
    const level = gameLevels[currentLevel];
    const requiredFilters = level.requiredFilters;
    
    // Check if filters are in correct order
    for (let i = 0; i < appliedFilters.length; i++) {
        if (appliedFilters[i] !== requiredFilters[i]) {
            return 0;
        }
    }
    
    // Calculate progress based on correctly applied filters
    const progressPerFilter = Math.floor(100 / requiredFilters.length);
    const quality = Math.min(100, progressPerFilter * appliedFilters.length);
    
    // If all filters are applied correctly, return 100%
    if (appliedFilters.length === requiredFilters.length && 
        appliedFilters.every((filter, index) => filter === requiredFilters[index])) {
        return 100;
    }
    
    return quality;
}

// Update level buttons state
function updateLevelButtons() {
    levelButtons.forEach(button => {
        const level = parseInt(button.dataset.level);
        if (completedLevels.has(level)) {
            button.classList.add('completed');
            button.style.opacity = '1';
            button.style.cursor = 'pointer';
        } else {
            button.classList.remove('completed');
            button.style.opacity = '1';
            button.style.cursor = 'pointer';
        }
    });
}

// Handle level completion
function handleLevelCompletion() {
    if (currentLevel < 6) {
        // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ —É—Å–ø—ñ—Ö
        statusMessage.textContent = '–í—ñ—Ç–∞—î–º–æ! –†—ñ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω–æ —É—Å–ø—ñ—à–Ω–æ! –ü–µ—Ä–µ—Ö–æ–¥—å—Ç–µ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è!';
        statusMessage.style.color = 'green';
        
        // –î–æ–¥–∞—î–º–æ –∞–Ω—ñ–º–∞—Ü—ñ—é –¥–ª—è –∫–Ω–æ–ø–∫–∏ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è
        const nextLevelButton = document.querySelector(`[data-level="${currentLevel + 1}"]`);
        if (nextLevelButton) {
            nextLevelButton.style.animation = 'pulse 1s ease-in-out 3';
        }
        
        // –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞–Ω –ø–æ—Ç–æ—á–Ω–æ—ó –∫–Ω–æ–ø–∫–∏
        const currentButton = document.querySelector(`[data-level="${currentLevel}"]`);
        if (currentButton) {
            currentButton.classList.add('completed');
            currentButton.style.backgroundColor = '#4CAF50';
        }
    } else if (currentLevel === 6) {
        // –°—Ç–≤–æ—Ä—é—î–º–æ –µ–ª–µ–º–µ–Ω—Ç –¥–ª—è —Ñ—ñ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–∏–≤—ñ—Ç–∞–Ω–Ω—è
        const victoryScreen = document.createElement('div');
        victoryScreen.className = 'victory-screen';
        victoryScreen.innerHTML = `
            <div class="victory-content">
                <h2>üéâ –í—ñ—Ç–∞—î–º–æ! –í–∏ —Å–ø—Ä–∞–≤–∂–Ω—ñ–π –º–∞–π—Å—Ç–µ—Ä –æ—á–∏—â–µ–Ω–Ω—è –≤–æ–¥–∏! üéâ</h2>
                <p>–í–∏ —É—Å–ø—ñ—à–Ω–æ –ø—Ä–æ–π—à–ª–∏ –≤—Å—ñ —Ä—ñ–≤–Ω—ñ —Ç–∞ –¥–æ–≤–µ–ª–∏ —Å–≤–æ—é –º–∞–π—Å—Ç–µ—Ä–Ω—ñ—Å—Ç—å —É –ø—Ä–æ—Ü–µ—Å–∞—Ö –æ—á–∏—â–µ–Ω–Ω—è –≤–æ–¥–∏.</p>
                <p>–í–∞—à—ñ –∑–Ω–∞–Ω–Ω—è –¥–æ–ø–æ–º–æ–∂—É—Ç—å –∑–±–µ—Ä–µ–≥—Ç–∏ —á–∏—Å—Ç–æ—Ç—É –≤–æ–¥–∏ —É –Ω–∞—à–æ–º—É —Å–≤—ñ—Ç—ñ! üíß‚ú®</p>
                <div class="victory-buttons">
                    <button onclick="location.reload()">–°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É</button>
                    <button onclick="window.location.href='index.html'">–ù–∞ –≥–æ–ª–æ–≤–Ω—É</button>
                </div>
            </div>
        `;
        document.body.appendChild(victoryScreen);
        
        // –î–æ–¥–∞—î–º–æ –∫–æ–Ω—Ñ–µ—Ç—Ç—ñ
        const duration = 5 * 1000;
        const animationEnd = Date.now() + duration;
        const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 1001 };

        function randomInRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        const interval = setInterval(function() {
            const timeLeft = animationEnd - Date.now();

            if (timeLeft <= 0) {
                return clearInterval(interval);
            }

            const particleCount = 50 * (timeLeft / duration);
            
            confetti(Object.assign({}, defaults, {
                particleCount,
                origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
            }));
            confetti(Object.assign({}, defaults, {
                particleCount,
                origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
            }));
        }, 250);
    }
}

// Handle filter drop
function handleFilterDrop(e) {
    e.preventDefault();
    const filterId = e.dataTransfer.getData('text/plain');
    const filterElement = document.querySelector(`[data-filter="${filterId}"]`);
    
    if (!filterElement) return;
    
    // Check if filter can be added
    const level = gameLevels[currentLevel];
    const nextRequiredFilter = level.requiredFilters[appliedFilters.length];
    
    if (filterId !== nextRequiredFilter) {
        statusMessage.textContent = `–°–ø–æ—á–∞—Ç–∫—É –ø–æ—Ç—Ä—ñ–±–Ω–æ –¥–æ–¥–∞—Ç–∏ ${getFilterName(nextRequiredFilter)}!`;
        statusMessage.style.color = 'red';
        return;
    }
    
    // Add filter to applied filters
    appliedFilters.push(filterId);
    
    // Create visual representation of applied filter
    const appliedFilter = document.createElement('div');
    appliedFilter.className = 'applied-filter';
    appliedFilter.textContent = filterElement.textContent;
    
    // Ensure filters container exists in water glass
    let appliedFiltersContainer = waterGlass.querySelector('.applied-filters');
    if (!appliedFiltersContainer) {
        appliedFiltersContainer = document.createElement('div');
        appliedFiltersContainer.className = 'applied-filters';
        waterGlass.appendChild(appliedFiltersContainer);
    }
    
    // Add to the end of the list
    appliedFiltersContainer.appendChild(appliedFilter);
    
    // Update water quality and color
    const quality = calculateWaterQuality();
    updateWaterQuality(quality);
    updateWaterColor(quality);
    
    // Check if level is completed
    if (quality === 100) {
        completedLevels.add(currentLevel);
        updateLevelButtons();
        handleLevelCompletion();
        
        // Ensure the current level button is marked as completed
        const currentButton = document.querySelector(`[data-level="${currentLevel}"]`);
        if (currentButton) {
            currentButton.classList.add('completed');
            currentButton.style.backgroundColor = '#4CAF50';
        }
    }
    
    // Update task completion visual feedback
    updateTaskCompletion();
}

// Helper function to get filter name
function getFilterName(filterId) {
    const filterMap = {
        'carbon': '–í—É–≥—ñ–ª—å–Ω–∏–π —Ñ—ñ–ª—å—Ç—Ä',
        'mineral': '–ú—ñ–Ω–µ—Ä–∞–ª—ñ–∑–∞—Ü—ñ—è',
        'membrane': '–ú–µ–º–±—Ä–∞–Ω–Ω–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è',
        'uv': '–£–§-–æ—á–∏—â–µ–Ω–Ω—è',
        'separation': '–°–µ–ø–∞—Ä–∞—Ü—ñ—è',
        'chemical': '–•—ñ–º—ñ—á–Ω–µ –æ—á–∏—â–µ–Ω–Ω—è',
        'precipitation': '–û—Å–∞–¥–∂–µ–Ω–Ω—è',
        'ion': '–Ü–æ–Ω–Ω–∏–π –æ–±–º—ñ–Ω',
        'adsorption': '–ê–¥—Å–æ—Ä–±—Ü—ñ—è'
    };
    return filterMap[filterId] || filterId;
}

// Add new function to update task completion visual feedback
function updateTaskCompletion() {
    const tasks = document.querySelectorAll('#level-tasks li');
    appliedFilters.forEach((filter, index) => {
        if (tasks[index]) {
            tasks[index].classList.add('completed');
        }
    });
}

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î–º–æ –ø–µ—Ä—à–∏–π —Ä—ñ–≤–µ–Ω—å —Ç–∞ —Ä–æ–∑–±–ª–æ–∫–æ–≤—É—î–º–æ –π–æ–≥–æ
    gameLevels[1].unlocked = true;
    
    // –†–æ–∑–±–ª–æ–∫–æ–≤—É—î–º–æ –≤—Å—ñ —Ä—ñ–≤–Ω—ñ, —è–∫—ñ –±—É–ª–∏ –ø—Ä–æ–π–¥–µ–Ω—ñ —Ä–∞–Ω—ñ—à–µ
    for (let i = 1; i <= 6; i++) {
        if (completedLevels.has(i) && i < 6) {
            gameLevels[i + 1].unlocked = true;
        }
    }
    
    initGame(1);
    
    // Level selection
    levelButtons.forEach(button => {
        button.addEventListener('click', () => {
            const level = parseInt(button.dataset.level);
            initGame(level);
        });
    });
    
    // Reset button
    document.querySelector('.reset-button').addEventListener('click', () => {
        resetWaterGlass();
    });
    
    // Drag and drop functionality
    const filterItems = document.querySelectorAll('.filter-item');
    filterItems.forEach(item => {
        item.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', item.dataset.filter);
        });
    });
    
    waterGlass.addEventListener('dragover', (e) => e.preventDefault());
    waterGlass.addEventListener('drop', handleFilterDrop);
}); 